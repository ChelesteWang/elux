import {deepMerge, moduleExists} from '@elux/core';
import {routeMeta, routeConfig} from './basic';
import {excludeDefault} from './deep-extend';

interface EluxLocationData {
  url: string;
  pathname: string;
  args: Record<string, any>;
  pagename?: string;
  _pathArgs?: Record<string, any>;
  _params?: Record<string, any>;
}
export interface EluxLocationPayload extends EluxLocationData {
  _locationState?: LocationStateData;
  _nativeLocation?: NativeLocationData;
}

interface NativeLocationData {
  url: string;
  pathname: string;
  query: string;
}
export interface NativeLocationPayload extends NativeLocationData {
  _eluxLocation?: EluxLocationData;
}

interface LocationStateData {
  url: string;
  pagename: string;
  params: Record<string, any>;
}
interface LocationStatePayload extends LocationStateData {
  _eluxLocation?: EluxLocationData;
  _optimizedEluxLocation?: EluxLocationData;
}

const eluxLocationCaches = {
  getItem(url: string): EluxLocationPayload | undefined {
    return undefined;
  },
  setItem(item: EluxLocationPayload) {},
  updateItem(data: Partial<EluxLocationPayload>): EluxLocationPayload {},
};

const nativeLocationCaches = {
  getItem(url: string): NativeLocationPayload | undefined {
    return undefined;
  },
  setItem(item: NativeLocationPayload) {},
  updateItem(data: Partial<NativeLocationPayload>): NativeLocationPayload {},
};

const locationStateCaches = {
  getItem(url: string): LocationStatePayload | undefined {
    return undefined;
  },
  setItem(item: LocationStatePayload) {},
  updateItem(data: Partial<LocationStatePayload>): LocationStatePayload {},
};

function checkUrl(data: {url?: string; pathname?: string; args?: Record<string, any>}): [string, string, string, Record<string, any> | undefined] {
  let pathname: string, query: string, args: Record<string, any> | undefined;
  if (data.url) {
    pathname = data.url.split('?')[0];
    query = data.url.replace(/^.+?(\?|$)/g, '');
    if (!query) {
      args = {};
    } else if (query === '{}' || query.charAt(0) !== '{' || query.charAt(query.length - 1) !== '}') {
      query = '';
      args = {};
    }
  } else {
    pathname = data.pathname || '';
    query = data.args && Object.keys(data.args).length ? JSON.stringify(data.args) : '';
    args = data.args || {};
  }
  pathname = `/${pathname.replace(/^\/+|\/+$/g, '')}`;
  pathname === '/' ? '/index' : pathname;
  const url = [pathname, query && `?${query}`].join('');
  return [url, pathname, query, args];
}

function createEluxLocation(dataOrUrl: string | {pathname: string; args: Record<string, any>}): EluxLocation {
  const [url, pathname, query, args] = checkUrl(typeof dataOrUrl === 'string' ? {url: dataOrUrl} : dataOrUrl);
  return buildEluxLocation({url, pathname, query, args});
}

function buildEluxLocation(payload: EluxLocationPayload): EluxLocation {
  let item = eluxLocationCaches.getItem(payload.url);
  if (item) {
    const updated: null | Record<string, any> = Object.keys(payload).reduce((data, key) => {
      if (!item![key] === undefined && payload[key] !== undefined) {
        if (!data) {
          data = {};
        }
        data[key] = payload[key];
      }
      return data;
    }, null as null | Record<string, any>);
    if (updated) {
      item = eluxLocationCaches.updateItem(updated);
    }
  } else {
    eluxLocationCaches.setItem(payload);
    item = payload;
  }
  return new EluxLocation(item);
}

function createNativeLocation(dataOrUrl: string | {pathname: string; query: string}): NativeLocation {
  // const [url, pathname, query, args] = checkUrl(typeof dataOrUrl === 'string' ? {url: dataOrUrl} : dataOrUrl);
  // return buildEluxLocation({url, pathname, query, args});
}

function buildNativeLocation(payload: NativeLocationPayload): NativeLocation {
  let item = nativeLocationCaches.getItem(payload.url);
  if (item) {
    const updated: null | Record<string, any> = Object.keys(payload).reduce((data, key) => {
      if (!item![key] === undefined && payload[key] !== undefined) {
        if (!data) {
          data = {};
        }
        data[key] = payload[key];
      }
      return data;
    }, null as null | Record<string, any>);
    if (updated) {
      item = nativeLocationCaches.updateItem(updated);
    }
  } else {
    nativeLocationCaches.setItem(payload);
    item = payload;
  }
  return new NativeLocation(item);
}

function buildLocationState(payload: LocationStatePayload): LocationState {}

export class EluxLocation implements EluxLocationPayload {
  readonly url!: string;
  readonly pathname!: string;
  readonly pagename!: string;
  readonly args!: Record<string, any>;
  readonly _params?: Record<string, any>;
  readonly _pathArgs?: Record<string, any>;
  readonly _nativeLocation?: NativeLocationData;
  readonly _locationState?: LocationStateData;

  static toUrl(pathname: string, args: Record<string, any>): string {
    const query = Object.keys(args).length ? JSON.stringify(args) : '';
    return [pathname, query && `?${query}`].join('');
  }
  constructor(payload: EluxLocationPayload) {
    Object.assign(this, payload);
    this.init();
  }
  update(payload: Partial<EluxLocationPayload>): void {}
  init(): void {
    let {pagename, args} = this;
    const {pathname} = this;
    if (!pagename) {
      const {pagenameList, notfoundPagename} = routeMeta;
      const _pathname = `${pathname}/`;
      const _pagename = pagenameList.find((name) => _pathname.startsWith(name));
      if (_pagename) {
        pagename = _pagename.substr(0, _pagename.length - 1);
      } else {
        pagename = notfoundPagename;
      }
    }
    if (!args) {
      const query = this.url.replace(/^.+?(\?|$)/g, '');
      if (query) {
        try {
          args = JSON.parse(query);
        } catch (e) {
          //env.console.error(e);
        }
      }
      args = args || {};
    }
    this.update({pagename, args});
  }
  getPathArgs(): Record<string, any> {
    if (!this._pathArgs) {
      const {pagenameMap, notfoundPagename} = routeMeta;
      const _pagename = `${this.pagename}/`;
      let arrArgs: Array<string | undefined>;
      if (this.pagename === notfoundPagename) {
        arrArgs = [this.pathname];
      } else {
        const _pathname = `${this.pathname}/`;
        arrArgs = _pathname
          .replace(_pagename, '')
          .split('/')
          .map((item) => (item ? decodeURIComponent(item) : undefined));
      }
      let _pathArgs: Record<string, any> = {};
      if (pagenameMap[_pagename]) {
        _pathArgs = pagenameMap[_pagename].argsToParams(arrArgs);
      }
      this.update({_pathArgs});
    }
    return this._pathArgs!;
  }
  getParams(): Record<string, any> {
    if (!this._params) {
      const {args} = this;
      const pathArgs = this.getPathArgs();
      const _params: Record<string, any> = deepMerge({}, pathArgs, args);
      const modules = moduleExists();
      Object.keys(_params).forEach((moduleName) => {
        if (!modules[moduleName]) {
          delete _params[moduleName];
        }
      });
      this.update({_params});
    }
    return this._params!;
  }
  getLocationState(): LocationState {
    if (!this._locationState) {
      const pagename = this.pagename;
      const params = this.getParams();
      this.update({_locationState: {url: LocationState.toUrl(pagename, params), pagename, params}});
    }
    const {url, pathname, args, pagename, _pathArgs, _params} = this;
    return buildLocationState({...this._locationState!, _eluxLocation: {url, pathname, args, pagename, _pathArgs, _params}});
  }
  getNativeLocation(): NativeLocation {
    if (!this._nativeLocation) {
      const {nativeLocationMap} = routeMeta;
      const {pathname, query} = nativeLocationMap.out({pathname: this.pathname, args: this.args});
      this.update({_nativeLocation: {url: NativeLocation.toUrl(pathname, query), pathname, query}});
    }
    const {url, pathname, args, pagename, _pathArgs, _params} = this;
    return buildNativeLocation({...this._nativeLocation!, _eluxLocation: {url, pathname, args, pagename, _pathArgs, _params}});
  }
}

export class NativeLocation implements NativeLocationPayload {
  readonly url!: string;
  readonly pathname!: string;
  readonly query!: string;
  readonly _eluxLocation?: EluxLocationData;

  static toUrl(pathname: string, query: string): string {
    return [pathname, query && `?${routeConfig.paramsKey}=${encodeURIComponent(query)}`].join('');
  }
  constructor(payload: NativeLocationPayload) {
    Object.assign(this, payload);
  }
  update(payload: Partial<NativeLocationPayload>): void {}

  getEluxLocation(): EluxLocation {
    if (!this._eluxLocation) {
      const {nativeLocationMap} = routeMeta;
      const {pathname, args} = nativeLocationMap.in({pathname: this.pathname, query: this.query});
      this.update({_eluxLocation: {url: EluxLocation.toUrl(pathname, args), pathname, args}});
    }
    const {url, pathname, query} = this;
    return buildEluxLocation({...this._eluxLocation!, _nativeLocation: {url, pathname, query}});
  }
  private joinQuery(params: Record<string, string> | undefined): string {
    return Object.keys(params || {})
      .map((key) => `${key}=${encodeURIComponent((params as any)[key])}`)
      .join('&');
  }
  private splitQuery(query: string): Record<string, string> | undefined {
    if (!query) {
      return undefined;
    }
    return query.split('&').reduce((params, str) => {
      const sections = str.split('=');
      if (sections.length > 1) {
        const [key, ...arr] = sections;
        if (!params) {
          params = {};
        }
        params[key] = decodeURIComponent(arr.join('='));
      }
      return params;
    }, undefined as any);
  }
}

export class LocationState implements LocationStatePayload {
  readonly url!: string;
  readonly pagename!: string;
  readonly params!: Record<string, any>;
  //public readonly isWhole?: Boolean;
  readonly _eluxLocation?: EluxLocationData;
  readonly _optimizedEluxLocation?: EluxLocationData;

  static toUrl(pagename: string, params: Record<string, any>): string {
    const query = Object.keys(params).length ? JSON.stringify(params) : '';
    return [pagename, query && `?${query}`].join('');
  }

  constructor(payload: LocationStatePayload) {
    Object.assign(this, payload);
  }
  update(payload: Partial<LocationStatePayload>): void {}
  init(): void {
    let {params} = this;
    const query = this.url.replace(/^.+?(\?|$)/g, '');
    if (!params) {
      if (query) {
        try {
          params = JSON.parse(query);
        } catch (e) {
          //env.console.error(e);
        }
      }
      params = params || {};
    }
    this.update({params});
  }
  getEluxLocation(): EluxLocation {
    const {url, pagename, params} = this;
    if (this._optimizedEluxLocation) {
      return buildEluxLocation({...this._optimizedEluxLocation, _locationState: {url, pagename, params}});
    }
    if (!this._eluxLocation) {
      this.update({_eluxLocation: {url: EluxLocation.toUrl(pagename, params), pathname: pagename, args: params, _params: params, _pathArgs: {}}});
    }
    return buildEluxLocation({...this._eluxLocation!, _locationState: {url, pagename, params}});
  }
  getOptimizedEluxLocation(): EluxLocation {
    if (!this._optimizedEluxLocation) {
      const {params, pagename} = this;
      const {pagenameMap} = routeMeta;
      const _pagename = `${this.pagename}/`;
      const minParams = excludeDefault(params, routeMeta.defaultParams, true);
      let pathname: string;
      let _pathArgs: Record<string, any>;
      if (pagenameMap[_pagename]) {
        const pathArgsArr = this.toStringArgs(pagenameMap[_pagename].paramsToArgs(minParams));
        pathname =
          _pagename +
          pathArgsArr
            .map((item) => (item ? encodeURIComponent(item) : ''))
            .join('/')
            .replace(/\/*$/, '');
        _pathArgs = pagenameMap[_pagename].argsToParams(pathArgsArr);
      } else {
        pathname = '/index';
        _pathArgs = {};
      }
      const args = excludeDefault(minParams, _pathArgs, false);
      this.update({
        _optimizedEluxLocation: {url: EluxLocation.toUrl(pathname, args), pathname, args, pagename, _params: params, _pathArgs},
      });
    }
    const {url, pagename, params} = this;
    return buildEluxLocation({...this._optimizedEluxLocation!, _locationState: {url, pagename, params}});
  }
  private toStringArgs(arr: any[]): Array<string | undefined> {
    return arr.map((item) => {
      if (item === null || item === undefined) {
        return undefined;
      }
      return item.toString();
    });
  }
}
