# 微模块

### 从产品角度

```
    某个大型应用包含A,B,C,D,E,F,G等若干功能，原来一直是整体打包出售，直到某天一个客户说：你们这个应用太贵了，我们只需要A,B,C,D功能，能不能便宜一点？产品经理找到开发人员讨论此事...
```

- 后端说：我们后端使用了微服务架构，可以按客户要求部署相关的服务，问题不大。
- 前端说：最近正流行微前端，我们可以将应用拆分成 3 个子应用：

  - 【基础应用】包含功能：A
  - 【子应用 1】包含功能：B、C、D
  - 【子应用 2】包含功能：E、F、G

  这 3 个子应用可以独立或是组合部署，这样等于有 3 个套餐可以供客户选择：

  - 套餐 A: 基础应用+子应用 1+子应用 2
  - 套餐 B: 基础应用+子应用 1
  - 套餐 C: 基础应用+子应用 2

```
Okay，看上去很美好的解决了当前的问题，可是不久又接到一个客户说：这3个套餐都不太适合我们，我们只想要A、C、E、G功能，可以多加一个套餐吗？于是产品经理又找到开发人员讨论此事...
```

- 前端说：这就有点为难了，这个客户要 ABCD，那个要 ACEG，那个要 ABDF，这有多少组合呀，难道我要一个功能做成一个子应用吗？

每个功能都做成一个子应用显然不太现实，那可不可以把每个功能封装成一个可以独立安装的模块呢？

### 从开发角度

&emsp;&emsp;或许你会说：我们系统是内部系统，根本就没打算出售，后期也不会有这样的需求。从技术开发的角度来说，不管什么系统，大了、复杂了总需要拆分，否则越来越难管理、编译越来越慢。对于多个工程之间的公共代码功能你打算怎么复用呢？是简单粗暴的复制粘贴？还是直接软链接？

比如：“发送短信验证码”、“忘记密码”等业务功能，是完全可以在多个项目之间复用的通用功能。

## 将业务功能放进模块

模块在前端开发中无处不再，最常用的比如:

> 安装模块 npm install jquery

> 使用模块 import jquery from 'jquery'

如果我们的功能 A,B,C,D,E,F,G 都能封装成一个独立的模块该多好，需要 D 功能的适合只需要：

> npm install D

> import LoginForm from 'D/views/LoginForm'

“这样...感觉有点奇怪，我们平时会把一个 component 组件封装成一个 npm 包，但很少会把业务功能也封装成 npm 包...这样可以吗？”

为什么不可以呢？模块本质上只不过是高内聚、低耦合的一些相关资源的集合，没人规定不能将业务组件放进 npm 包呀。这样还能借助于 npm 的版本管理机制来管理需求功能点的迭代。

以后我们称这些业务模块为：**_微模块_**

### 微模块的划分

微模块是围绕一个特定业务功能的相关资源的集合，它可能包含 JS、CSS、图片、多媒体、组件、工具库等等...

- 划分原则：`高内聚、低耦合`。（微模块应当有自己清晰的边界）
- 划分视角：`业务功能`。（非 UI 功能）

我们可以借助于后端 Restful 的理念，每种 Resorece 资源的维护（增删改查）通常是高内聚的，资源和资源之间通常是低耦合的，所以一种常用思路是我们将每种资源的维护封装成一个微模块。

## Elux 中的微模块

在 elux 中通常按照这样的目录结构来组织微模块：

```
├── moduleA
│     ├── assets //静态资源
│     ├── components //UI组件
│     ├── views //业务组件
│     │     ├── LoginForm
│     │     ├── BottomNav
│     │     └── ...
│     ├── model.ts //处理业务逻辑
│     ├── index.ts //封装与导出
│     └── package.json //定义npm包
```

从中可以看出，一个微模块其实就是一个小小的工程生态系统，并没有什么颠覆性的认知，需要特别说明的是：

- view(业务组件)：我们称包含业务逻辑的组件叫 View，以区别普通的 UI 组件 Component
- model(业务模型)：我们把业务逻辑的处理入口集中在此文件中，它包含 2 大职能:
  - moduleState：模块状态的定义
  - actionHandler：模块状态的维护与逻辑编排

Elux 框架的典型工程结构：

```
src
├── modules
│      ├── moduleA
│      │     ├── assets
│      │     ├── consts
│      │     ├── utils
│      │     ├── components
│      │     ├── views
│      │     ├── model.ts
│      │     └── index.ts
│      ├── moduleB
│      ├── moduleC
```

业内常用的典型工程结构：

```
src
├── assets
├── consts
│      ├── moduleA
│      ├── moduleB
│      ├── moduleC
├── utils
├── components
│      ├── moduleA
│      ├── moduleB
│      ├── moduleC
├── containers
├── pages
│      ├── moduleA
│      ├── moduleB
│      ├── moduleC
├── models
│      ├── moduleA
│      ├── moduleB
│      ├── moduleC
│
```

对比可以看出，最大的区别是：传统工程是以文件职能作为一级分类，模块化作为次级分类；而 Elux 是反过来，以模块作为一级分类，文件职能作为次级分类，这种改变使得模块和模块之间的隔离变得更加清晰明了。

## 微模块的好处

最后要总结微模块的好处吗？微模块无非就是将业务功能也模块化、将模块与模块之间的解耦执行得更加彻底。所以如果你认可解耦的好处、能深刻体会到模块化带来的便捷与快感，在此也就无须我多言了...
