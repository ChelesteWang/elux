# 前端微模块

## 微前端够用吗？

### 从产品的角度

某个大型应用包含A,B,C,D,E,F,G等若干功能，原来一直是整体打包出售...

随着用户需求的多样化，有的用户仅需要部分功能，于是聪明的前端架构师“小李”利用时下流行的微前端技术，将应用拆分成了的 3 个常用的子应用：

- 【基础应用】包含功能：A
- 【子应用A】包含功能：B,C,D
- 【子应用B】包含功能：E,F,G

这样等于有 3 个套餐可以供客户选择：

- 套餐A：基础应用 + 子应用A
- 套餐B：基础应用 + 子应用B
- 套餐C：基础应用 + 子应用A + 子应用B

然而用户的需求越来越精细化，有的需要ABCD，有的需要ACEG，有的需要ABDF，而且同一个功能可能还存在历史版本的不同，这让“小李”无可适从。

> 微前端不足够灵活、粒度不足够细

### 从开发的角度

对于“发送短信验证码”、“忘记密码”等某些通用的业务流程和功能，你是如何在不同工程之间共享和维护的呢？是简单的复制粘贴？还是一股脑全放基座里面？还是部署一个独立的url页面跳转？

> 微前端没解决工程之间代码复用和维护的问题

## 将业务功能放进模块

对于后端开发来说，按业务功能来划分模块几乎是业界共识，而在前端开发中往往是按UI界面来切割模块，这样的前端模块实际上只是Component组件，不具备独立性与完整性。

如果我们将完整的业务功能（包括UI组件、样式、图片、交互流程、业务逻辑、API请求、数据管理等）都打包到一个NPM包中，并利用NPM的版本和依赖管理机制来维护客户需求，岂不美哉？

比如某客户需要 A,C1,E2,G 功能，我们只需要安装相应版本的NPM包：

> npm install A C@1 E@2 G

至此，我们称这些包含完整业务功能的模块为 **_前端微模块_**，可见所谓的微模块其实就是包含业务功能的NPM模块。

## 微模块的划分

::: tip 微模块是实现特定业务功能所需要的相关资源集合

- 划分视角: `业务功能`（非UI界面）
- 划分原则: `高内聚、低耦合`（有清晰的边界）

:::

请注意"高内聚、低耦合"是唯一的划分标准，并不要求单一职责，所以一个微模块中可能包含多个功能点、多个UI组件，一组相关视图。

如果二个微模块之间紧密依赖，交互密切，请不要分割它们，这样会使问题复杂化。一种常用思路是借助于Restful理念，将每种资源的增删改查封装成一个独立的微模块。

## 微模块的开发和维护

微模块的开发和维护就是对NPM包的开发和维护，并不附加任何新的学习成本，你需要做的只是理清与其它模块的依赖关系，以保证它的独立性与易用性。

## 微模块的部署

通常有2种方式使用和部署微模块：

- 静态编译：微模块作为一个NPM包被安装到工程中，通过打包工具（如webpack）正常编译打包即可。这种方式的优点是代码产物得到打包工具的各种去重和优化，缺点是当某个模块更新时，需要整体重新打包。
- 动态注入：利用打包工具的动态加载功能（如webpack5 的 Module Federation）将微模块作为子应用部署（与时下流行的微前端类似）。这种方式的优点是各子应用独立部署运行，当某子应用中的微模块更新时，其它应用无需重新编译，缺点是没有打包工具的整体编译与优化，代码和资源容易重复加载或冲突。
  
本框架对以上2种部署方式都有支持和示例。

## Elux中的微模块

我们先看一下时下流行的前端工程目录：

```md
src
├── assets
├── consts
│      ├── ModuleA
│      │      ├── Const1.ts //A中使用的一些常量
│      ├── ModuleB
│             ├── Const2.ts //B中使用的一些常量
├── utils
├── components
│      ├── ModuleA
│      │      ├── Component1.ts //A中使用的一些UI组件
│      ├── ModuleB
│             ├── Component2.ts //B中使用的一些UI组件
├── containers
├── pages
│      ├── ModuleA
│      │      ├── Page1.ts //A中使用的一些页面
│      ├── ModuleB
│             ├── Page2.ts //B中使用的一些页面
├── models
│      ├── ModuleA
│      │      ├── Store1.ts //A中使用一些状态定义
│      ├── ModuleB
│             ├── Store2.ts //B中使用一些状态定义
│
```

相信90%以上的前端工程师都喜欢用这种类似的工程结构，其特点是以“文件职能”作为一级分类、“功能模块”作为次级分类。

现在如果我需要拿掉ModuleB，或者新增ModuleC，你将不得不进行多个目录的操作。随着文件越来越多，相互引用越来越复杂，ModuleB的相关资源和依赖像一堆乱麻散落在各个不同文件和文件夹中，你会发现要干净的剥离ModuleB是一个巨大的任务...

::: tip 那应当如何改进呢？

- 将“功能模块”作为一级分类，“文件职能”作为次级分类
- 注意模块的对外封装，不要随意绕过封装来引用模块内部资源

:::

以下是Elux工程的常用结构：

```md
src
├── modules
│      ├──  ModuleA
│      │     ├── assets
│      │     │     ├── imgs //A中使用的一些图片等
│      │     ├── consts
│      │     │     ├── Const1.ts //A中使用的一些常量
│      │     ├── utils
│      │     ├── components
│      │     │     ├── Component1.ts //A中使用的一些UI组件
│      │     ├── views
│      │     │     ├── View1.ts //A中使用的一些业务视图
│      │     ├── model.ts //A的数据模型
│      │     └── index.ts //A的对外封装与导出
│      │ 
│      ├── ModuleB
│      ├── ModuleC
```

可以看到在Elux工程中，所有与功能模块相关的文件都被放到了一个独立的文件夹中，并通过index文件统一对外导出，这便是Elux中微模块得以独立开发、安装和运行的基础。

## 微模块的好处

需要总结微模块的好处吗？如果你认可解耦的好处、能深刻体会到模块化给这个世界带来的便捷与革新，也就无需多言了...
